from .Nodes import *

# Begin -- grammar generated by Yapps
import sys, re
from yapps import runtime

class R7RSScanner(runtime.Scanner):
    patterns = [
        ('"do"', re.compile('do')),
        ('"if"', re.compile('if')),
        ('"set!"', re.compile('set!')),
        ('""', re.compile('')),
        ('"\\."', re.compile('\\.')),
        ('"lambda"', re.compile('lambda')),
        ('\\s+', re.compile('\\s+')),
        ('OPAREN', re.compile('\\(')),
        ('CPAREN', re.compile('\\)')),
        ('NUMBER', re.compile('[0-9]+')),
        ('BOOLEAN', re.compile('#t|#f|#true|#false')),
        ('IDENTIFIER', re.compile('[-+.><?*/!@%^&=a-zA-Z0-9_]+')),
        ('STRING', re.compile('"(.*?)"')),
    ]
    def __init__(self, str,*args,**kw):
        runtime.Scanner.__init__(self,None,{'\\s+':None,},str,*args,**kw)

class R7RS(runtime.Parser):
    Context = runtime.Context
    def identifier(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'identifier', [])
        IDENTIFIER = self._scan('IDENTIFIER', context=_context)
        return Id(IDENTIFIER)

    def expression(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'expression', [])
        _token = self._peek('IDENTIFIER', 'OPAREN', 'BOOLEAN', 'NUMBER', 'STRING', context=_context)
        if _token == 'IDENTIFIER':
            identifier = self.identifier(_context)
            return identifier
        elif _token != 'OPAREN':
            literal = self.literal(_context)
            return literal
        else: # == 'OPAREN'
            OPAREN = self._scan('OPAREN', context=_context)
            structured_form = self.structured_form(_context)
            CPAREN = self._scan('CPAREN', context=_context)
            return structured_form

    def structured_form(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'structured_form', [])
        _token = self._peek('"set!"', '"if"', '"lambda"', 'IDENTIFIER', 'OPAREN', '"do"', 'BOOLEAN', 'NUMBER', 'STRING', context=_context)
        if _token == '"set!"':
            assignment = self.assignment(_context)
            return assignment
        elif _token not in ['"if"', '"lambda"', '"do"']:
            procedure_call = self.procedure_call(_context)
            return procedure_call
        elif _token == '"if"':
            conditional = self.conditional(_context)
            return conditional
        elif _token == '"lambda"':
            lambda_expression = self.lambda_expression(_context)
            return lambda_expression
        else: # == '"do"'
            derived_expression = self.derived_expression(_context)
            return derived_expression

    def lambda_expression(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'lambda_expression', [])
        self._scan('"lambda"', context=_context)
        formals = self.formals(_context)
        body = self.body(_context)
        return Lambda(formals, body)

    def formals(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'formals', [])
        _token = self._peek('IDENTIFIER', 'OPAREN', context=_context)
        if _token == 'IDENTIFIER':
            identifier = self.identifier(_context)
            return Arguments([identifier], [])
        else: # == 'OPAREN'
            OPAREN = self._scan('OPAREN', context=_context)
            paren_formals = self.paren_formals(_context)
            CPAREN = self._scan('CPAREN', context=_context)
            return Arguments(paren_formals[0], paren_formals[1])

    def paren_formals(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'paren_formals', [])
        _token = self._peek('IDENTIFIER', '""', context=_context)
        if _token == 'IDENTIFIER':
            args = []
            while 1:
                identifier = self.identifier(_context)
                args.append(identifier)
                if self._peek('IDENTIFIER', '"\\."', 'CPAREN', context=_context) != 'IDENTIFIER': break
            optional_args = None
            if self._peek('"\\."', 'CPAREN', context=_context) == '"\\."':
                optional_args = self.optional_args(_context)
            return [args, optional_args]
        else: # == '""'
            epsilon = self.epsilon(_context)
            return ([],[])

    def optional_args(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'optional_args', [])
        self._scan('"\\."', context=_context)
        identifier = self.identifier(_context)
        return identifier

    def body(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'body', [])
        sequence = self.sequence(_context)
        return sequence

    def sequence(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'sequence', [])
        seq = []
        while 1:
            expression = self.expression(_context)
            seq.append(expression)
            if self._peek('IDENTIFIER', 'OPAREN', 'BOOLEAN', 'NUMBER', 'STRING', 'CPAREN', context=_context) not in ['IDENTIFIER', 'OPAREN', 'BOOLEAN', 'NUMBER', 'STRING']: break
        return seq

    def program(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'program', [])
        p = []
        while 1:
            expression = self.expression(_context)
            p.append(expression)
            if self._peek('IDENTIFIER', 'OPAREN', 'BOOLEAN', 'NUMBER', 'STRING', '""', context=_context) not in ['IDENTIFIER', 'OPAREN', 'BOOLEAN', 'NUMBER', 'STRING']: break
        epsilon = self.epsilon(_context)
        return Program(p)

    def epsilon(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'epsilon', [])
        self._scan('""', context=_context)
        return None

    def literal(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'literal', [])
        self_evaluating = self.self_evaluating(_context)
        return self_evaluating

    def self_evaluating(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'self_evaluating', [])
        _token = self._peek('BOOLEAN', 'NUMBER', 'STRING', context=_context)
        if _token == 'BOOLEAN':
            BOOLEAN = self._scan('BOOLEAN', context=_context)
            boolean = BOOLEAN
            return Bool(True if (boolean == "#t" or boolean == "#true") else False)
        elif _token == 'NUMBER':
            NUMBER = self._scan('NUMBER', context=_context)
            return Num(int(NUMBER))
        else: # == 'STRING'
            STRING = self._scan('STRING', context=_context)
            return Str(STRING[1:-1])

    def assignment(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'assignment', [])
        self._scan('"set!"', context=_context)
        identifier = self.identifier(_context)
        expression = self.expression(_context)
        return Assign(identifier, expression)

    def procedure_call(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'procedure_call', [])
        operands = []
        operator = self.operator(_context)
        while self._peek('IDENTIFIER', 'OPAREN', 'BOOLEAN', 'NUMBER', 'STRING', 'CPAREN', context=_context) != 'CPAREN':
            operand = self.operand(_context)
            operands.append(operand)
        return Call(operator, operands)

    def operand(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'operand', [])
        expression = self.expression(_context)
        return expression

    def operator(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'operator', [])
        expression = self.expression(_context)
        return expression

    def conditional(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'conditional', [])
        self._scan('"if"', context=_context)
        test = self.test(_context)
        consequent = self.consequent(_context)
        alternate = self.alternate(_context)
        return Conditional(test, consequent, alternate)

    def test(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'test', [])
        expression = self.expression(_context)
        return expression

    def consequent(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'consequent', [])
        expression = self.expression(_context)
        return expression

    def alternate(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'alternate', [])
        _token = self._peek('IDENTIFIER', 'OPAREN', '""', 'BOOLEAN', 'NUMBER', 'STRING', context=_context)
        if _token != '""':
            expression = self.expression(_context)
            return expression
        else: # == '""'
            epsilon = self.epsilon(_context)
            return None

    def derived_expression(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'derived_expression', [])
        do_expr = self.do_expr(_context)
        return do_expr

    def do_expr(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'do_expr', [])
        self._scan('"do"', context=_context)
        OPAREN = self._scan('OPAREN', context=_context)
        iter_specs = []
        while self._peek('CPAREN', 'OPAREN', context=_context) == 'OPAREN':
            iteration_spec = self.iteration_spec(_context)
            iter_specs.append(iteration_spec)
        CPAREN = self._scan('CPAREN', context=_context)
        OPAREN = self._scan('OPAREN', context=_context)
        test = self.test(_context)
        do_result = self.do_result(_context)
        CPAREN = self._scan('CPAREN', context=_context)
        cmds = []
        while self._peek('IDENTIFIER', 'OPAREN', 'BOOLEAN', 'NUMBER', 'STRING', 'CPAREN', context=_context) != 'CPAREN':
            expression = self.expression(_context)
            cmds.append(expression)
        return Do(iter_specs, test, do_result, cmds)

    def iteration_spec(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'iteration_spec', [])
        step = None
        OPAREN = self._scan('OPAREN', context=_context)
        identifier = self.identifier(_context)
        init = self.init(_context)
        if self._peek('CPAREN', 'IDENTIFIER', 'OPAREN', 'BOOLEAN', 'NUMBER', 'STRING', context=_context) != 'CPAREN':
            step = self.step(_context)
        CPAREN = self._scan('CPAREN', context=_context)
        return IterSpec(identifier, init, step)

    def init(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'init', [])
        expression = self.expression(_context)
        return expression

    def step(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'step', [])
        expression = self.expression(_context)
        return expression

    def do_result(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'do_result', [])
        _token = self._peek('IDENTIFIER', 'OPAREN', '""', 'BOOLEAN', 'NUMBER', 'STRING', context=_context)
        if _token != '""':
            sequence = self.sequence(_context)
            return sequence
        else: # == '""'
            epsilon = self.epsilon(_context)
            return None


def parse(rule, text):
    P = R7RS(R7RSScanner(text))
    return runtime.wrap_error_reporter(P, rule)

# End -- grammar generated by Yapps


